# Chapter 3 型と演算子
## 静的型付け　動的型付け
  プログラムが自動的に処理にあった（本当に合っているわけではない）データ型に定義
  してくれるものが、動的型付け。コードを書く人が型を定義づけるのが、静的型付け。

  動的は、コンパイルによってバグが発見できるが、静的は、実行しないとバグがわからない
  という問題がある。静的は、型を宣言せずとも変数や関数を使用できる。（簡単に実装できるが、
  その利便性がバグの見つけずらさを上回るとは思わない。）

  PHP7から、スカラ型(boolean, int, float, string)の型指定ができるように。
  declare(strict_types=1);を記述することで型指定ができる。
  function hello(int $v): int {
    return "hello";
  }
  hello(); // error発生 返り値の型が違うため
  hello("hello"); // error発生 引数の型が違うため

## データ型
  echo gettype(); または var_dump(); で確認ができる。
  # boolean 論理値
    true 1
    false 0 0.0 "" "0" [] null 空のタグから作成されたSimpleXMLElement
  # integer 整数値
  # float 浮動小数点数
  # string 文字列
    ""と'' ””で表現された文字列は、エスケープ文字や変数を展開できる。''はできない。
    ヒアドキュメント（変数展開する）とNowDoc（変数展開しない）

    クライアントの入力値は自動的に文字列型になっている。数値を受け取っている
    と思っても文字列を受け取っていることになる。条件分岐やその他の処理を書く際、
    その点を考慮しなければならない。比較演算では、できれば厳密な比較を使うのが安全か？

  # array 配列
    連想配列

  # object オブジェクト
    クラスをインスタンス化したもの

  # resource リソース
    なんらかの外部リソースへの参照を保持するもの。

  # null ぬる
    null表示条件
      nullが代入されている
      値が何も代入されていない
      unset()されている

## 自動キャストが起こる時
  # 異なる型同士での演算時
  # 演算子、制御構造、関数、メソッドが特定の型の引数を必要としており、それと異なる
  型の値を引数に渡した時

  123 == 0123 // true

## 配列 array, []
連想配列
 $hello = [
   'ja' => 'konnitiwa',
   'en' => 'hello',
  ];
多次元配列 // ネストされた配列
